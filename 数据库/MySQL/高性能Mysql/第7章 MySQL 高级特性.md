## 分区表

分区表是一个独立的逻辑表，但是底层由多个物理子表组成。

MySQL 在创建表时使用 `partition by` 子句定义每个分区存放的数据。在执行查询的时候，优化器会根据分区定义过滤数据，这也就无需扫描所有分区。

以下场景适合分区：

- 表非常大以至于无法全部放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据。
- 分区表的数据更容易维护。例：批量删除大批量数据可以使用清除整个分区的方式，还可以对一个独立分区进行优化、检查、修复等操作。
- 分区表的数据可以分布在不同的物理设备上，从而高效的利用多个硬件设备。
- 可以使用分区表来避免某些特殊的瓶颈，例：InnoDB 的单个索引互斥访问、ext3 文件系统的 inode 锁竞争。
- 备份和恢复独立的分区，在非常大的数据集场景下效果非常好。

分区表限制：

- 一个表最多只能有 1024 个分区。
- 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。
- 分区表无法使用外键约束。
- 所有分区都必须使用相同的存储引擎

某些场景分区表可能遇见的问题：

- **分区列和索引不匹配：**如果定义的索引列和分区列不匹配，会导致查询无法进行分区过滤。

  > 经常会在关联查询时遇到问题，如：分区表在关联顺序中是第二个表，并且关联使用的索引和分区条件并不匹配。那么关联时针对第一个表符合条件的每一行，都需要访问并搜索第二个表的所有分区。

- **选择分区的成本可能会很高**

- **打开并锁住所有底层表的成本可能很高**

- **维护分区的成本可能很高**



## 视图

视图表本身是一个虚拟表，不存放任何数据。在使用 SQL 语句访问视图的时候，它返回的数据是 MySQL 从其它表生成的。

## 存储代码

### 存储过程和函数

优点：

- 在服务器内部执行，离数据最近，在服务器上执行还可以节省带宽和网络延迟。（这并没用什么优势）
- 代码重用，可以方便的统一业务规则，保证某些行为总是一致。
- 简化代码的维护和版本更新。
- 可以帮助提升安全，比如提供更细粒度的权限控制。
- 服务端可以缓存存储过程的执行计划，这对于需要反复调用的过程，会很大程度降低消耗。
- 因为是在服务器端部署，备份、维护都可以在服务器端完成，维护工作会变简单。
- 在应用开发和数据库开发人员之间更好的分工。

缺点：

- MySQL 没有提供好用的开发和调试工具，编写 MySQL 的存储代码比其他数据库要难些。
- 和应用程序代码，存储代码效率要稍微差些。存储代码可使用的函数非常有限，所以使用存储代码很难编写复杂的字符串维护功能，也很难实现太复杂的逻辑。
- 存储代码可能会给应用程序代码的部署带来额外的复杂性。原本只需要部署应用代码和库表结构变更，现在还需要额外的部署 MySQL 内部的存储代码。
- 因为存储程序部署在服务器内，可能会有安全隐患。如果将非标准的加密功能放在存储程序中，若数据库被攻破，数据也就泄漏了。但是若将加密函数放在应用程序代码中，那么攻击者必须同时攻破程序和数据库才能获得数据。
- 存储过程会给数据库服务器增加额外的压力，而数据服务器的扩展性比应用服务器要差。
- MySQL 没有什么选项可以控制存储程序的资源消耗，所以在存储过程中的一个小错误，可能会把服务器拖死。

MySQL 的架构本身和优化器使得存储代码有一些天然的限制：

- 优化器无法使用关键字 deterministic 来优化单个查询中多次调用存储函数的情况
- 优化器无法评估存储函数的执行成本
- 每个连接都有独立的存储过程的执行计划缓存。如果有多个连接需要调用同一个存储过程，将会浪费缓存空间来反复缓存同样的执行计划

### 触发器

触发器限制：

- 对于每一个表的每一个事件，最多只能定义一个触发器
- MySQL 只支持基于行的触发。（触发器始终是针对一条记录，而不是针对整个 SQL 语句，如果变更数据集非常大的话，效率会很低）
- 触发器会掩盖服务器背后的工作
- 触发器的问题很难排查，如果某个性能问题和触发器有关，会很难分析和定位
- 触发器可能导致死锁和锁等待

### 事件

事件在一个独立事件调度线程被初始化，这个线程和处理连接的线程没有任何关系。通常会把复杂的 SQL 都封装到一个存储过程中，在事件执行时只需要做一个简单的 call 调用。

### 游标

MySQL 在服务器端提供只读、单向的游标，而且只能在存储过程或者更底层的客户端 API 中使用。因为 MySQL 游标中指向的对象都是存储在临时表中而不是实际查询到的数据，所以游标总是只读的。

### 绑定变量

`insert into tb1(col1,col2,col3) values (?,?,?);`

MySQL 在使用绑定变量时可以更高效的执行大量重复语句：

- 在服务器端只需要解析一次  SQL 语句。
- 在服务器端某些优化器的工作只需要执行一次，因为它会缓存一部分的执行计划。
- 以二进制的方式发送参数和句柄，节省了很多内存，减少了网络开销
- 相对安全，减少了 SQL 注入和攻击的风险



