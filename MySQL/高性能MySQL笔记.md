### 并发控制

处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁（shared lock）和排他锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）

##### 锁的概念：

读锁：读锁是共享的，也可以说是相互不阻塞的。多个用户再同一时刻可以同时读取同一个资源，而互不干扰。

写锁：写锁是排他的，一个写锁会阻塞其它的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

#### 锁粒度

一种提高共享资源并发性的方式让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有资源。理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。

问题是加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量的时间来管理锁，而不是存取数据，那么系统的性能就会受到影响。

### 锁策略

是在锁的开销和数据的安全性之间寻求平衡，这种平衡也会影响到性能。

#### 表锁（table lock）

表锁是 MySQL 中的基本锁策略，并且是开销最小的策略。

表锁会锁定整张表，一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。

写锁会比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面（写锁可以插入到锁队列中读锁的前面，读锁则不能插入到写锁的前面）

**服务器会为 ALTER TABLE 之类的语句使用表锁，而忽略存储引擎的锁机制**

#### 行级锁（row lock）

行级锁可以最大程度的支持并发处理（同时也带来了最大的锁开销）

### 隔离级别

SQL 标准定义了四种隔离级别，每种级别都规定了一个事务中所作的修改，哪些在事务内和事务间是可见的，哪些是不可见的，较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

- READ UNCOMMITTED（未提交读）
    - 在 READ UNCOMMITTED 级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这被称为脏读（drity read）。这个级别会导致很多问题，从性能上说，READ UNCOMMITTED 不会比其他的级别好，实际应用中一般很少使用。
- READ COMMITTED（提交读）
    - 大多数数据库系统的默认隔离级别是 READ COMMITTED（MySQL 不是）。READ COMMITTED 满足隔离性的简单定义，这个级别也叫做不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。
- REPEATABLE READ（可重复读）
    - 解决了脏读的问题。该级别保证了在同一个事务中多次读取同样的记录的结果是一致的。但在理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。**幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录，会产生幻行（Phantom Row）**。此隔离级别是 MySQL 的默认事务隔离级别。
- SERIALIZABLE（可串行化）
    - SERIALIZABLE 是最高的隔离级别。它通过强制事务串行执行，避免了幻读问题。SERIALIZABLE 会在读取的每一行数据上都加上锁，所以可能导致大量的超时和锁争用问题。实际应用中很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑该级别。

![1546397656358](assets/1546397656358.png)

### 死锁

指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

案例：

![1546397893973](assets/1546397893973.png)

> InnoDB  处理死锁的方式是将持有最少行级排他锁的事务进行回滚

### 事务日志

事务日志可以提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的追加方式，因此写日志的操作是磁盘上一小块区域内的顺序 I/O，而不像随机 I/O 需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久后，内存中被修改的数据在后台可以慢慢刷回磁盘，称为预写式日志，修改数据需要写两次磁盘。

### InnoDB 存储引擎

InnoDB 是 MySQL 的默认事务引擎。他被设计用来处理大量的短期事务，短期事务大部分是正常提交，很少会被回滚。**InnoDB 的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行**

## MySQL 基准测试

#### 名词解释

**吞吐量：单位时间内的事务处理数**

**响应时间或者延迟：用于测试任务所需的整体时间**

**并发性：在任意时间有多少同时发生的并发请求（错位的理解：经常会被表示成多少用户在同一时间浏览一个 Web 站点）**

**可扩展性：给系统增加一倍的工作，在理想的情况下可以获得两个结构（即吞吐量增加一倍），同时响应时间也必须在可接受范围**

