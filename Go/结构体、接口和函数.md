> go 语言中的函数有具名和匿名之分；
>
> 具名函数一般对应于包级的函数，是匿名函数的一种特例，当匿名函数引用了外部作用域中的变量时就成了闭包函数，闭包函数是函数式编程语言的核心。
>
> 包的导入时从 main 包开始的，如果包含了其它包，会以文件名或包路径名的字符串顺序导入。
>
> 如果某个包被多次导入则只会执行一次导入，然后创建和初始化包的常量和变量，再调用包里的 init 函数。
>
> 如果一个包有多个 init 函数调用顺序可能是以文件名的顺序调用，同一个文件内有个多个 init 则是一个出现的顺序依次调用。最后当 main 包的所有包级常量、变量被创建和初始化，并且 init 函数被执行后，才会进入 `main.main` 函数，程序开始正常执行。

## 方法

Go 语言不支持面向对象中的继承特性，在 Go 语言中，通过结构体内置的匿名成员来实现继承。嵌入匿名成员不仅继承匿名成员的内部成员，而且可以继承匿名成员类型所对应的方法。这种继承方式并不能实现 C++ 中的多态特性。所有继承来的方法接受者参数依然是那个匿名成员本身，而不是当前变量。

```go
type Point struct{X,Y float64}

type ColoredPoint struct {	// ColoredPoint 是 Point 的 的子类
  Point	// Point 是基类
  Color color.RGBA
}
```



## 函数

Go1.4 以前，Go 的动态栈采用的是分段式的动态栈（采用一个链表来实现动态栈，每个链表的节点内存位置不会发生变化），但是链表实现的动态栈对某些导致跨越链表不同节点的热点调用性能影响较大，因为相邻的链表节点它们在内存位置一般是不相邻的，这会增加 CPU 高速缓存命中失败的几率。为了解决热点调用的 CPU 缓存命中率问题，Go1.4 以后改用连续的动态栈实现（类似一个动态数组的结构来表示栈）。连续动态栈带来的问题是，当连续动态栈增长时，需要将之前的数据移动到新的内存空间，这会导致之前栈中全部变量的地址发生变化。虽然 Go 语言运行时会自动更新引用了地址变化的栈变量指针，但是需要明白 Go 语言中指针不再是固定不变的，因此不能随意将地址保存到数值变量中，Go 语言的地址也不能随意保存到不在 GC 控制的环境中，使用 CGO时不能在 C 语言中长期持有 Go 语言对象的地址。



如果返回值命名了，可以通过名字来修改返回值，也可以通过 `defer` 语句在 return 之后修改返回值。

```go
func Incr() (v int) { // 此时的 v 等于 43
  defer func(){
    v++
  }()
  return 42
}
```

当可变参数是一个空接口类型时，调用者是否解包可变参数会导致不同的结果

```go
func Print(a ...interface{}) {
  fmt.Println(a...)
}
var a = []interface{}{123,"abc"}
Print(a...) // 123 abc
Print(a)   // [123,abc]
```



## 接口

Go 接口和对象之间的转换太灵活，需要人为的限制这种无意之间的适配，常见的做法是定义一个含特殊方法来区分接口

```go
// 例如 runtime 包中 Error 接口定义了一个特有的方法 RuntimeErro 方法，避免其它类型无意中适配了该接口
type runtime.Error interface {
  error
  
  RuntimeError()
}
```

还可以在包内对一个接口定义一个私有的方法，因此只有在包内部实现这个私有方法才能满足这个接口，不过这种方法的副作用就是，这个接口只能包内部使用，外部包正常情况下是无法直接创建满足该接口对象的。也有可以绕过的方法，可以通过结构体嵌入匿名类型成员，可以继承匿名类型的方法。

