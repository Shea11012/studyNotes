## 协程 goroutine

协程和操作系统线程之间并无一对一的关系，协程是根据一个或多个线程的可用性，映射在它们之上的。

协程工作在相同的地址空间，所以共享内存的方式一定是同步的，go 推荐使用 channels 来同步协程。

协程是轻量的，使用的内存很小，使用 4k 的内存就可以在堆中创建它，它们对栈进行分割从而可以动态的使用内存。栈的管理是自动的，不是由垃圾回收器管理，而是在协程退出后自动释放。

当 `main()` 函数返回时，程序退出，它不会等待任何其他非 main 协程的结束。

协程是独立的处理单元，一旦陆续启动协程，无法确定它们什么时候开始执行的，所以代码逻辑必须独立于协程调用的顺序。

go 协程与其他语言的不同：

- Go 协程意味着并行（或可以以并行的方式部署），协程一般不是这样的。
- Go 协程通过通道来通信，协程通过让出和恢复操作来通信。

## 通道 channel

Go 的一个特殊类型，`channel 通道`，可以通过它们发送类型化的数据在协程之间通信，从而避免内存共享会导致的一些错误。通道的通信方式保证了同步性。数据通过通道，同一时间只有一个协程可以访问数据，所以不会出现数据竞争。

声明通道：

```go
var i chan datatype	// 零值是 nil

// datatype 可以是任何类型
ch := make(chan string)
ch := make(chan func()) // 函数通道

// 带缓存的通带
buf := 100
ch := make(chan string,buf) // buf = 0 阻塞，buf > 0 非阻塞，相当于异步
```

通道的结构是类型化消息队列，它是先进先出（FIFO）结构

通信操作符：`<-` ，这个操作符表示了数据的传输，信息按照箭头的方向流动。

```go
ch <- int1 	// 表示用通道 ch 发送变量 int1
int2 := <- ch	// 表示变量 int2 从通道 ch 接收数据
<- ch	// 可以单独调用获取通道的下一个值，当前值会被丢弃，但是可以用来验证

var send_only chan<- int	// channel 只能接收值
var recv_only <-chan int	// channel 只能发送值
if <- ch != 1000 {
    ...
}
```

### 通道阻塞

默认情况下，通信是同步且无缓冲的，在有接收者接收数据之前，发送不会结束，所以一个无缓存的通道在没有空间来保存数据的时候，必须要有一个接收者准备好接收通道的数据，所以通道的发送、接收操作在对方准备好之前是阻塞的。

对于同一个通道，如果 ch 中的数据无人接收，就无法再给通道传入其他数据。新的输入无法在通道非空的情况下传入，所以发送操作会等待 ch 再次变为可用状态（就是通道值被接收可以传入变量）。

### 关闭通道

```go
close(ch) // 这是一个内置的方法，接收一个只发送或者双向的通道
```

### 切换协程

从不同的并发执行的协程中获取值可以通过关键字 `select`。

```go
// select 会选择多个通道中的一个，如果都阻塞了会等待直到其中一个可以处理，如果有多个随机选择一个，如果没有通道操作可以处理并且有 default 语句，就会执行 default。
select {
    case u:= <- ch1:
    ...
    case v:= <- ch1:
    ...
    default:
}
```

### 带缓冲的通道

```go
// 测试最先接受到哪个,使用了带缓冲的通道
resp := make(chan string,3)
go func() { resp <- request('baidu.com')  }()
go func() { resp <- request('google.com') }()
go func() { resp <- request('taobao.com') }()
return <-resp
```

**Tips：每个协程都使用了同一个通道的情况下，需要确保足够的容量，这样就避免了剩余的 goroutines 因为没有被接收而被永远卡住的情况，这种情况被称之为 goroutines 泄漏。泄漏的 goroutines 不会被自动回收，因此需要确保每个不再需要的 goroutine 能正常退出。**

