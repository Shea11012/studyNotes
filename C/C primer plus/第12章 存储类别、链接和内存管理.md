## ANSI C 类型限定符

#### const 类型限定符

以 const 关键字声明的对象，其值不能通过赋值或者递增、递减来修改

```c
const float * pf; // 表示 pf 指向的值不能修改，而 pf 本身的值可以改变
float * const pt; // 表示 pt 本身的值不能更改，而 pt 指向的值可以改变
const float * const ptr; // 表示 ptr 既不能指向别处，它所指向的值也不能改变
```

#### volatile 类型限定符

volatile 限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中共享数据

```c
val = x;
/*
* 中间代码
*/
res = x;
```

编译器会注意到以上代码使用了两次 x，但未改变它的值。于是编译器把 x 值临时储存在寄存器中，然后在 res 需要的时候才从寄存器中（而不是原始内存位置上）读取 x 的值，以节约时间，这个过程被称为高速缓存（caching）。如果一些其他代理在以上两条语句之间改变了 x 值，这样就不能优化了。如果没有 volatile 关键字，编译器就不会知道这种事情是否发生。因此，为了安全起见，编译器不会进行高速缓存。这是在 ANSI 之前的情况。现在，如果声明没有 volatile 关键字，编译器会假定变量的值在使用过程中不变，然后再尝试优化代码。

#### restrict 类型限定符

restrict 限定符允许编译器优化部分代码以更好的支持运算，它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。



### 概念

静态内存、自动内存和动态分配内存的属性。

静态内存的数量在编译时确定。

静态数据在载入程序时被载入内存。

在程序运行时，自动变量被分配或释放，自动变量占用的内存数量随着程序的运行会不断变化，可以把自动内存看作是可重复利用的工作区。

动态分配的内存也会增加或减少，但是这是由函数调用控制的。



### 存储类别

- **自动**：在块中不带存储类别说明符或带 auto 存储类别说明符声明的变量（或作为函数头中的形参）属于自动存储类别，具有自动存储期、块作用域、无链接。如果未初始化自动变量，它的值是未定义的。
- **寄存器**：在块中带 register 存储类别说明符声明的变量（或作为函数头中的形参）属于寄存器存储类别，具有自动存储期、块作用域、无链接，且无法获取其地址。把一个变量声明为寄存器变量即请求编译器将其储存到访问速度最快的区域。如果未初始化寄存器变量，它的值是未定义的。
- **静态、无链接**：在块中带有 static 存储类别说明符声明的变量属于 “静态、无链接” 存储类别，具有静态存储其、块作用域、无链接。只在编译时被初始化一次。如果未显式初始化，它的字节都被设置为 0。
- **静态、外部链接**：在所有函数外部且没有使用 static 存储类别说明符声明的变量属于 “静态、外部链接”存储类别，具有静态存储期、文件作用域、外部链接。只能在编译器被初始化一次。如果未显式初始化，它的字节都被设置为 0。
- **静态、内部链接**：在所有函数外部且使用了 static 存储类别说明符声明的变量属于 “静态、内部链接”存储类别，具有静态存储期、文件作用域、内部链接。只能在编译器被初始化一次。如果未显式初始化，它的字节都被设置为 0。