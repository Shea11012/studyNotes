## 指针

##### 地址运算符：&  &后跟一个变量名，表示该变量的地址

##### 地址运算符：*   *后跟一个变量名，表示给出储存在指针指向地址上的值

示例：

```c
nurse = 22;
ptr = &nurse;  // 指向 nurse 指针
val = *ptr;  // 把 ptr 指向的地址上的值赋给 val
```

#### 指针基本操作

- **赋值**：可以把地址赋给指针。例如：使用数组名、带地址运算符（&）的变量名、另一个指针进行赋值。注意，地址应该和指针类型兼容（就是说不能把 double 类型的地址赋给指向 int 的指针）
- **解引用**：* 运算符给出指针指向地址上储存的值
- **取址**：指针变量也有自己的地址和值。对于指针而言，& 运算符给出指针本身的地址。
- **指针与整数相加**：使用 + 运算符把指针与整数相加，或整数与指针相加，无论哪种情况都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。
- **递增指针**：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。
- **指针减去一个整数**：可以使用 - 运算符从一个指针中减去一个整数，指针必须是第一个运算对象，整数是第二个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。
- **递减指针**：同指针递增
- **指针求差**：计算两个指针的差值，通常，求差的两个指针分别指向同一个数组的不同元素。通过计算求出两元素之间的距离，差值的单位与数组类型的单位相同。如果两个不同数组的进行求差运算可能会得出一个值，或者导致运行错误。
- **比较：**使用关系运算符可以比较两个指针的值，前提是两个指针的类型必须相同。

> 不要解引用未初始化的指针
>
> ```c
> double *p; // 未初始化的指针
> *p = 2.4; // 报错
> ```
>
> 创建一个指针时，系统只分配了存储指针本身的内存，并未分配存储数据的内存。因此在使用指针之前，必选先用已分配的地址初始化它。

## 数组

数组初始化：

```c
int arr[3] = {1,2,3};
// 指定初始化
int arr[3] = {[2] = 3}; // 未初始化的元素都被置为 0
```

C 给数组分配空间时，保证指向数组后面第一个位置的指针仍是有效指针

**对形式参数使用 const，这样如果在函数中不小心使用了 arr[i]++ ，编译器会捕获这个错误 **

## 指针和数组

- 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件，许多计算机都是按字节编址（表示内存中的每个字节都是按顺序编号）
- 在指针前面使用 * 可以得到该指针所指向对象的值
- 指针加 1 ，指针的值递增它所指向类型的大小（以字节为单位）

```c
dates + 2 == &dates[2]; 	// 相同的地址
*(dates + 2) == dates[2];	// 相同的值    
// * 间接运算符的优先级高于 +
*dates + 2 // dates 第 1 个元素值加 2
 *(dates + 2) // 获取第三个元素值
```

`*(arr + n)` 的含义表示：到内存的 arr 位置，然后移动 n 个单元，检索储存在哪里的值

**声明数组形参：**

```c
// 在声明函数原型时可以省略参数名，以下4种是等价的
int sum(int *arr,int n);
int sum(int *,int n);
int sum(int arr[],int n);
int sum(int [],int n);
// 在函数定义时不能省略参数名
int sum(int arr[],int n);
```

```c
total += *start++; // 先执行 *start 操作，再对 start指针进行递增 
total += *++start; // 先执行 start 指针递增操作，再执行 *start
```

#### 保护数组中的数据

因为数组相当于指针，在对数组进行错误的操作时可能会修改了原数组的数据，所以可以对函数原型的形参使用 **const** ，这样修改了原数组的数据就会被编译器捕获，并报一个错误。

```c
int sum(const int [],int n);

int sum(const int arr[],int n) 
{
	arr[i]++; // 这样就会报一个错误
}
```

 

#### 变长数组（variable-length array，VLA）

允许使用变量表示数组的维度。

变长数组不是指可以修改已创建数组的大小，一旦创建了变长数组，它的大小则保持不变，这里的“变”指的是，在创建数组时，可以使用变量指定数组的维度。

变长数组的限制：

- 必须是自动存储类别，表示不能使用 static 或 extern 存储类别说明符
- 不能在声明中初始化

```c
// 函数原型声明一个变长数组
int sum(int,int ar[*][*]);	// 可以省略原型中的形参名，必须使用星号代替省略的维度
```



#### 复合字面量

字面量是除符号常量外的常量。

> 5 是 int 类型字面量
>
> 81.3 是 double 类型字面量
>
> `‘y’` 是 char 类型的字面量
>
> `“elephant”` 是字符串字面量
>
> `(int [2]){10,20}`  去掉声明中的数组名，留下的 `int [2]` 即是复合字面量的类型名，复合字面量也可以省略大小，编译器可以自动计算初始化的元素个数 `(int []){10,20,30}`

**复合字面量是匿名的，所以不能先创建然后再使用它。必须在创建的同时使用它，使用指针记录地址就是一种用法。**

```c
int *p;
p = (int []){1,2,3};

int (*p2)[4]; // 声明一个指向 2 维数组的指针
pt2 = (int [2][4]){ {1,2,3,4},{1,2,3,4} };
```

## 复杂的声明

| 符号 | 含义         |
| ---- | ------------ |
| *    | 表示一个指针 |
| ()   | 表示一个函数 |
| []   | 表示一个数组 |

**tips：**

> 指针数组：首先它是一个数组，数组的元素都是指针，数组占用多少字节由数组本身决定。是储存指针的数组简称。
>
> 数组指针：首先它是一个指针，它指向一个数组。指针在 32 位下占 4 字节，64 位占 8 字节。是指向数组的指针的简称。

```c
int *p1[10];
```

> [] 的优先级比 * 要高。p1 先与 [] 结合，构成一个数组的定义，数组名为 p1。
>
> int * 修饰数组的内容，即数组的每个元素。
>
> 表示的含义是，这是一个数组，其包含 10 个指向 int 类型数据的指针，即指针数组。

```c
int (*p2)[10];
```

> () 的优先级比 [] 高，* 和 p2 构成了一个指针的定义，指针变量名为 p2 ，int 修饰的是数组的内容，即数组的每个元素。
>
> 数组在这里没有名字，是一个匿名数组。
>
> 表示的含义是，p2 是一个指针，它指向一个包含 10 个 int 类型数据的数组，即数组指针。

```c
int board[8][8];	// 声明一个二维数组，其值类型为 int
int **ptr;	// 声明一个指向指针的指针，被指向的指针指向 int
int *risks[10]; // 声明一个内含 10 个元素的数组，每个元素的数组都是一个指向 int 的指针
int *oof[3][4]; // 声明一个 3x4 的二维数组，每个元素都是指向 int 类型的指针
int (*uuf)[3][4]; // 声明 uuf 是一个 int 类型指针指向一个 3x4 的二维数组
int (*uof[3])[4]; // 声明 uof 是一个内含 3 个元素的指针数组，每个指针都指向了一个内含 4 个 int 类型的元素数组

// 函数
char *fump(int); // 返回字符指针的函数
char (*frump)(int); // 指向函数的指针，该函数的返回类型为 char
char (*frump[3])(int); // 内含 3 个指针的数组，每个指针都指向返回类型为 char 的函数

// typedef
typedef int arr5[5]; // 内含5个int类型的数组
typedef arr5 *p_arr5; // 指向数组的指针，该数组内含5个int类型的值
typedef p_arr5 arrp10[10]; // 内含10个指针数组，每个指针指向一个内含5个int类型的数组
```

